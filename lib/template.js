'use strict';
var __importDefault =
  (this && this.__importDefault) ||
  function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
Object.defineProperty(exports, '__esModule', {value: true});
const json_stable_stringify_1 = __importDefault(
  require('json-stable-stringify'),
);
exports.TSLINT_DISABLE = `/* tslint:disable */`;
exports.GENERATED_COMMENT = `// generated by typescript-json-validator`;
exports.IMPORT_INSPECT = `import {inspect} from 'util';`;
exports.IMPORT_AJV = tsConfig => {
  return tsConfig.allowSyntheticDefaultImports ||
    (tsConfig.esModuleInterop && /^es/.test(tsConfig.module)) ||
    tsConfig.module === 'system'
    ? `import Ajv from 'ajv';`
    : `import Ajv = require('ajv');`;
};
exports.DECLARE_KOA_CONTEXT = `export interface KoaContext {
  readonly request?: unknown; // {body?: unknown}
  readonly params?: unknown;
  readonly query?: unknown;
  throw(status: 400, message: string): unknown;
}`;
exports.importNamedTypes = (names, relativePath) =>
  `import {${names.join(', ')}} from '${relativePath}';`;
exports.importDefaultType = (name, relativePath) =>
  `import ${name} from '${relativePath}';`;
exports.importType = (name, relativePath, {isNamedExport}) =>
  isNamedExport
    ? exports.importNamedTypes([name], relativePath)
    : exports.importDefaultType(name, relativePath);
exports.declareAJV = options => `export const ajv = new Ajv(${json_stable_stringify_1.default(
  {
    coerceTypes: false,
    allErrors: true,
    ...options,
  },
)});

ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));
`;
exports.exportNamed = names => `export {${names.join(', ')}};`;
exports.declareSchema = (name, schema) =>
  `export const ${name} = ${json_stable_stringify_1.default(schema, {
    space: 2,
  })};`;
exports.addSchema = name => `ajv.addSchema(${name}, '${name}')`;
exports.DECLARE_VALIDATE_TYPE = `export type ValidateFunction<T> = ((data: unknown) => data is T) & Pick<Ajv.ValidateFunction, 'errors'>`;
exports.validateType = typeName => `ValidateFunction<${typeName}>`;
exports.compileSchema = (schemaName, typeName) =>
  `ajv.compile(${schemaName}) as ${exports.validateType(typeName)}`;
exports.validateFn = (
  typeName,
  schemaName,
) => `export const is${typeName} = ${exports.compileSchema(
  schemaName,
  typeName,
)};
export default function validate(value: unknown): ${typeName} {
  if (is${typeName}(value)) {
    return value;
  } else {
    throw new Error(
      ajv.errorsText(is${typeName}.errors!.filter((e: any) => e.keyword !== 'if'), {dataVar: '${typeName}'}) +
      '\\n\\n' +
      inspect(value),
    );
  }
}
`;
function typeOf(typeName, property, schema) {
  if (schema.definitions && schema.definitions[typeName]) {
    const typeSchema = schema.definitions[typeName];
    if (
      typeSchema.properties &&
      Object.keys(typeSchema.properties).includes(property)
    ) {
      return `${typeName}['${property}']`;
    }
  }
  return 'unknown';
}
exports.validateKoaRequestOverload = (
  typeName,
  schema,
) => `export function validateKoaRequest(typeName: '${typeName}'): (ctx: KoaContext) => {
  params: ${typeOf(typeName, 'params', schema)},
  query: ${typeOf(typeName, 'query', schema)},
  body: ${typeOf(typeName, 'body', schema)},
};`;
exports.VALIDATE_KOA_REQUEST_FALLBACK = `export function validateKoaRequest(typeName: string): (ctx: KoaContext) => {
  params: unknown,
  query: unknown,
  body: unknown,
};`;
exports.VALIDATE_KOA_REQUEST_IMPLEMENTATION = `export function validateKoaRequest(typeName: string): (ctx: KoaContext) => {
  params: any,
  query: any,
  body: any,
} {
  const params = ajv.getSchema(\`Schema#/definitions/\${typeName}/properties/params\`);
  const query = ajv.getSchema(\`Schema#/definitions/\${typeName}/properties/query\`);
  const body = ajv.getSchema(\`Schema#/definitions/\${typeName}/properties/body\`);
  const validateProperty = (
    prop: string,
    validator: any,
    ctx: KoaContext,
  ): any => {
    const data = prop === 'body' ? ctx.request && (ctx.request as any).body : (ctx as any)[prop];
    if (validator) {
      const valid = validator(data);
  
      if (!valid) {
        ctx.throw(
          400,
          'Invalid request: ' + ajv.errorsText(validator.errors!.filter((e: any) => e.keyword !== 'if'), {dataVar: prop}) + '\\n\\n' + inspect({params: ctx.params, query: ctx.query, body: ctx.request && (ctx.request as any).body}),
        );
      }
    }
    return data;
  };
  return (ctx) => {
    return {
      params: validateProperty('params', params, ctx),
      query: validateProperty('query', query, ctx),
      body: validateProperty('body', body, ctx),
    }
  };
}`;
exports.validateOverload = typeName =>
  `export function validate(typeName: '${typeName}'): (value: unknown) => ${typeName};`;
exports.VALIDATE_IMPLEMENTATION = `export function validate(typeName: string): (value: unknown) => any {
  const validator: any = ajv.getSchema(\`Schema#/definitions/\${typeName}\`);
  return (value: unknown): any => {
    if (!validator) {
      throw new Error(\`No validator defined for Schema#/definitions/\${typeName}\`)
    }
  
    const valid = validator(value);

    if (!valid) {
      throw new Error(
        'Invalid ' + typeName + ': ' + ajv.errorsText(validator.errors!.filter((e: any) => e.keyword !== 'if'), {dataVar: typeName}),
      );
    }

    return value as any;
  };
}`;
//# sourceMappingURL=template.js.map
